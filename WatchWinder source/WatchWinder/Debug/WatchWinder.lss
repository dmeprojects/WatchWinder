
WatchWinder.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000005ab  2**0
                  ALLOC, LOAD, DATA
  1 .text         000000c8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000013  00800100  00800100  000005ab  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  000005ab  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000d8  00000000  00000000  000005da  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001481  00000000  00000000  000006b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000778  00000000  00000000  00001b33  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000696  00000000  00000000  000022ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000264  00000000  00000000  00002944  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000211  00000000  00000000  00002ba8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000042b  00000000  00000000  00002db9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000098  00000000  00000000  000031e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000004  00000512  00000512  000005a6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000327c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text.ControlPowerLED 0000004c  00000378  00000378  0000040c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.ControlMotorEnable 00000046  000003c4  000003c4  00000458  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.TogglePowerLED 00000022  000004f0  000004f0  00000584  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.setup   00000052  00000326  00000326  000003ba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.InitTimer0 0000003a  00000450  00000450  000004e4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.InitInt0 0000002e  000004c2  000004c2  00000556  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.InitGPIO 00000046  0000040a  0000040a  0000049e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .bss.g_OnTimeSec 00000001  00800117  00800117  000005ab  2**0
                  ALLOC
 22 .bss.g_OnTimeMin 00000001  00800118  00800118  000005ab  2**0
                  ALLOC
 23 .bss.g_OnTimeHr 00000001  00800119  00800119  000005ab  2**0
                  ALLOC
 24 .bss.g_OnTimems 00000002  00800113  00800113  000005ab  2**0
                  ALLOC
 25 .bss.MotorTimer 00000002  00800115  00800115  000005ab  2**0
                  ALLOC
 26 .text.__vector_14 00000142  000000c8  000000c8  0000015c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.__vector_1 00000038  0000048a  0000048a  0000051e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .data.gStateMachine 00000001  0080011a  00000516  000005aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 29 .text.main    0000011c  0000020a  0000020a  0000029e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3a 00 	jmp	0x74	; 0x74 <__ctors_end>
   4:	0c 94 45 02 	jmp	0x48a	; 0x48a <__vector_1>
   8:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
   c:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  10:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  14:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  18:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  1c:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  20:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  24:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  28:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  2c:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  30:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  34:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  38:	0c 94 64 00 	jmp	0xc8	; 0xc8 <_etext>
  3c:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  40:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  44:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  48:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  4c:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  50:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  54:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  58:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  5c:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  60:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>
  64:	0c 94 89 02 	jmp	0x512	; 0x512 <__bad_interrupt>

00000068 <.dinit>:
  68:	01 00       	.word	0x0001	; ????
  6a:	01 1a       	sub	r0, r17
  6c:	80 01       	movw	r16, r0
  6e:	1a 01       	movw	r2, r20
  70:	1b 00       	.word	0x001b	; ????
  72:	05 16       	cp	r0, r21

00000074 <__ctors_end>:
  74:	11 24       	eor	r1, r1
  76:	1f be       	out	0x3f, r1	; 63
  78:	cf ef       	ldi	r28, 0xFF	; 255
  7a:	d8 e0       	ldi	r29, 0x08	; 8
  7c:	de bf       	out	0x3e, r29	; 62
  7e:	cd bf       	out	0x3d, r28	; 61

00000080 <__do_copy_data>:
  80:	e8 e6       	ldi	r30, 0x68	; 104
  82:	f0 e0       	ldi	r31, 0x00	; 0
  84:	40 e0       	ldi	r20, 0x00	; 0
  86:	17 c0       	rjmp	.+46     	; 0xb6 <__do_clear_bss+0x8>
  88:	b5 91       	lpm	r27, Z+
  8a:	a5 91       	lpm	r26, Z+
  8c:	35 91       	lpm	r19, Z+
  8e:	25 91       	lpm	r18, Z+
  90:	05 91       	lpm	r16, Z+
  92:	07 fd       	sbrc	r16, 7
  94:	0c c0       	rjmp	.+24     	; 0xae <__do_clear_bss>
  96:	95 91       	lpm	r25, Z+
  98:	85 91       	lpm	r24, Z+
  9a:	ef 01       	movw	r28, r30
  9c:	f9 2f       	mov	r31, r25
  9e:	e8 2f       	mov	r30, r24
  a0:	05 90       	lpm	r0, Z+
  a2:	0d 92       	st	X+, r0
  a4:	a2 17       	cp	r26, r18
  a6:	b3 07       	cpc	r27, r19
  a8:	d9 f7       	brne	.-10     	; 0xa0 <__do_copy_data+0x20>
  aa:	fe 01       	movw	r30, r28
  ac:	04 c0       	rjmp	.+8      	; 0xb6 <__do_clear_bss+0x8>

000000ae <__do_clear_bss>:
  ae:	1d 92       	st	X+, r1
  b0:	a2 17       	cp	r26, r18
  b2:	b3 07       	cpc	r27, r19
  b4:	e1 f7       	brne	.-8      	; 0xae <__do_clear_bss>
  b6:	e4 37       	cpi	r30, 0x74	; 116
  b8:	f4 07       	cpc	r31, r20
  ba:	31 f7       	brne	.-52     	; 0x88 <__do_copy_data+0x8>
  bc:	0e 94 05 01 	call	0x20a	; 0x20a <main>
  c0:	0c 94 62 00 	jmp	0xc4	; 0xc4 <_exit>

000000c4 <_exit>:
  c4:	f8 94       	cli

000000c6 <__stop_program>:
  c6:	ff cf       	rjmp	.-2      	; 0xc6 <__stop_program>

Disassembly of section .text:

00000512 <__bad_interrupt>:
 512:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.ControlPowerLED:

00000378 <ControlPowerLED>:
}

void ToggleAmbientLED (void)
{
	PINB |= (1<<AmbientLED);	
}
 378:	cf 93       	push	r28
 37a:	df 93       	push	r29
 37c:	1f 92       	push	r1
 37e:	cd b7       	in	r28, 0x3d	; 61
 380:	de b7       	in	r29, 0x3e	; 62
 382:	89 83       	std	Y+1, r24	; 0x01
 384:	89 81       	ldd	r24, Y+1	; 0x01
 386:	81 30       	cpi	r24, 0x01	; 1
 388:	69 f4       	brne	.+26     	; 0x3a4 <ControlPowerLED+0x2c>
 38a:	85 e2       	ldi	r24, 0x25	; 37
 38c:	90 e0       	ldi	r25, 0x00	; 0
 38e:	25 e2       	ldi	r18, 0x25	; 37
 390:	30 e0       	ldi	r19, 0x00	; 0
 392:	f9 01       	movw	r30, r18
 394:	20 81       	ld	r18, Z
 396:	22 60       	ori	r18, 0x02	; 2
 398:	fc 01       	movw	r30, r24
 39a:	20 83       	st	Z, r18
 39c:	81 e0       	ldi	r24, 0x01	; 1
 39e:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <g_PowerLEDState>
 3a2:	0b c0       	rjmp	.+22     	; 0x3ba <ControlPowerLED+0x42>
 3a4:	85 e2       	ldi	r24, 0x25	; 37
 3a6:	90 e0       	ldi	r25, 0x00	; 0
 3a8:	25 e2       	ldi	r18, 0x25	; 37
 3aa:	30 e0       	ldi	r19, 0x00	; 0
 3ac:	f9 01       	movw	r30, r18
 3ae:	20 81       	ld	r18, Z
 3b0:	2d 7f       	andi	r18, 0xFD	; 253
 3b2:	fc 01       	movw	r30, r24
 3b4:	20 83       	st	Z, r18
 3b6:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <g_PowerLEDState>
 3ba:	00 00       	nop
 3bc:	0f 90       	pop	r0
 3be:	df 91       	pop	r29
 3c0:	cf 91       	pop	r28
 3c2:	08 95       	ret

Disassembly of section .text.ControlMotorEnable:

000003c4 <ControlMotorEnable>:
 3c4:	cf 93       	push	r28
 3c6:	df 93       	push	r29
 3c8:	1f 92       	push	r1
 3ca:	cd b7       	in	r28, 0x3d	; 61
 3cc:	de b7       	in	r29, 0x3e	; 62
 3ce:	89 83       	std	Y+1, r24	; 0x01
 3d0:	89 81       	ldd	r24, Y+1	; 0x01
 3d2:	81 30       	cpi	r24, 0x01	; 1
 3d4:	49 f4       	brne	.+18     	; 0x3e8 <ControlMotorEnable+0x24>
 3d6:	88 e2       	ldi	r24, 0x28	; 40
 3d8:	90 e0       	ldi	r25, 0x00	; 0
 3da:	28 e2       	ldi	r18, 0x28	; 40
 3dc:	30 e0       	ldi	r19, 0x00	; 0
 3de:	f9 01       	movw	r30, r18
 3e0:	20 81       	ld	r18, Z
 3e2:	21 60       	ori	r18, 0x01	; 1
 3e4:	fc 01       	movw	r30, r24
 3e6:	20 83       	st	Z, r18
 3e8:	89 81       	ldd	r24, Y+1	; 0x01
 3ea:	88 23       	and	r24, r24
 3ec:	49 f4       	brne	.+18     	; 0x400 <__EEPROM_REGION_LENGTH__>
 3ee:	88 e2       	ldi	r24, 0x28	; 40
 3f0:	90 e0       	ldi	r25, 0x00	; 0
 3f2:	28 e2       	ldi	r18, 0x28	; 40
 3f4:	30 e0       	ldi	r19, 0x00	; 0
 3f6:	f9 01       	movw	r30, r18
 3f8:	20 81       	ld	r18, Z
 3fa:	2e 7f       	andi	r18, 0xFE	; 254
 3fc:	fc 01       	movw	r30, r24
 3fe:	20 83       	st	Z, r18
 400:	00 00       	nop
 402:	0f 90       	pop	r0
 404:	df 91       	pop	r29
 406:	cf 91       	pop	r28
 408:	08 95       	ret

Disassembly of section .text.TogglePowerLED:

000004f0 <TogglePowerLED>:

void TogglePowerLED (void)
{
 4f0:	cf 93       	push	r28
 4f2:	df 93       	push	r29
 4f4:	cd b7       	in	r28, 0x3d	; 61
 4f6:	de b7       	in	r29, 0x3e	; 62
	PINB |= (1<<PowerLED);
 4f8:	83 e2       	ldi	r24, 0x23	; 35
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	23 e2       	ldi	r18, 0x23	; 35
 4fe:	30 e0       	ldi	r19, 0x00	; 0
 500:	f9 01       	movw	r30, r18
 502:	20 81       	ld	r18, Z
 504:	22 60       	ori	r18, 0x02	; 2
 506:	fc 01       	movw	r30, r24
 508:	20 83       	st	Z, r18
}
 50a:	00 00       	nop
 50c:	df 91       	pop	r29
 50e:	cf 91       	pop	r28
 510:	08 95       	ret

Disassembly of section .text.setup:

00000326 <setup>:
	// Use timer2 to generate 50Hz PWM at OC2B (fast PWm, 8-bit, TOP = 0xFF (+/-61Hz))
	TCCR2A	=	(1<<WGM20) | (1<<WGM21) | (1<<COM2B1);	// Configure timer in PWM mode, non inverting
	TCCR2B  =	(1<<CS20) | (1<<CS21) | (1<<CS22);		// Set timer clock source to clock/1024 (15625Khz)
	OCR2B	=	0;										// 0% duty cycle
	DDRD	=	DDRD | (1<<3);						// Make sure PORTD.3 is set as output for the servo
}
 326:	cf 93       	push	r28
 328:	df 93       	push	r29
 32a:	cd b7       	in	r28, 0x3d	; 61
 32c:	de b7       	in	r29, 0x3e	; 62
 32e:	0e 94 28 02 	call	0x450	; 0x450 <InitTimer0>
 332:	0e 94 05 02 	call	0x40a	; 0x40a <InitGPIO>
 336:	0e 94 61 02 	call	0x4c2	; 0x4c2 <InitInt0>
 33a:	88 e2       	ldi	r24, 0x28	; 40
 33c:	90 e0       	ldi	r25, 0x00	; 0
 33e:	28 e2       	ldi	r18, 0x28	; 40
 340:	30 e0       	ldi	r19, 0x00	; 0
 342:	f9 01       	movw	r30, r18
 344:	20 81       	ld	r18, Z
 346:	fc 01       	movw	r30, r24
 348:	20 83       	st	Z, r18
 34a:	88 e2       	ldi	r24, 0x28	; 40
 34c:	90 e0       	ldi	r25, 0x00	; 0
 34e:	28 e2       	ldi	r18, 0x28	; 40
 350:	30 e0       	ldi	r19, 0x00	; 0
 352:	f9 01       	movw	r30, r18
 354:	20 81       	ld	r18, Z
 356:	20 62       	ori	r18, 0x20	; 32
 358:	fc 01       	movw	r30, r24
 35a:	20 83       	st	Z, r18
 35c:	88 e2       	ldi	r24, 0x28	; 40
 35e:	90 e0       	ldi	r25, 0x00	; 0
 360:	28 e2       	ldi	r18, 0x28	; 40
 362:	30 e0       	ldi	r19, 0x00	; 0
 364:	f9 01       	movw	r30, r18
 366:	20 81       	ld	r18, Z
 368:	28 62       	ori	r18, 0x28	; 40
 36a:	fc 01       	movw	r30, r24
 36c:	20 83       	st	Z, r18
 36e:	78 94       	sei
 370:	00 00       	nop
 372:	df 91       	pop	r29
 374:	cf 91       	pop	r28
 376:	08 95       	ret

Disassembly of section .text.InitTimer0:

00000450 <InitTimer0>:
 450:	cf 93       	push	r28
 452:	df 93       	push	r29
 454:	cd b7       	in	r28, 0x3d	; 61
 456:	de b7       	in	r29, 0x3e	; 62
 458:	84 e4       	ldi	r24, 0x44	; 68
 45a:	90 e0       	ldi	r25, 0x00	; 0
 45c:	22 e0       	ldi	r18, 0x02	; 2
 45e:	fc 01       	movw	r30, r24
 460:	20 83       	st	Z, r18
 462:	85 e4       	ldi	r24, 0x45	; 69
 464:	90 e0       	ldi	r25, 0x00	; 0
 466:	23 e0       	ldi	r18, 0x03	; 3
 468:	fc 01       	movw	r30, r24
 46a:	20 83       	st	Z, r18
 46c:	87 e4       	ldi	r24, 0x47	; 71
 46e:	90 e0       	ldi	r25, 0x00	; 0
 470:	2d e7       	ldi	r18, 0x7D	; 125
 472:	fc 01       	movw	r30, r24
 474:	20 83       	st	Z, r18
 476:	8e e6       	ldi	r24, 0x6E	; 110
 478:	90 e0       	ldi	r25, 0x00	; 0
 47a:	22 e0       	ldi	r18, 0x02	; 2
 47c:	fc 01       	movw	r30, r24
 47e:	20 83       	st	Z, r18
 480:	00 00       	nop
 482:	00 00       	nop
 484:	df 91       	pop	r29
 486:	cf 91       	pop	r28
 488:	08 95       	ret

Disassembly of section .text.InitInt0:

000004c2 <InitInt0>:


void InitInt0()
{
 4c2:	cf 93       	push	r28
 4c4:	df 93       	push	r29
 4c6:	cd b7       	in	r28, 0x3d	; 61
 4c8:	de b7       	in	r29, 0x3e	; 62
	//EICRA	=	(0<<ISC11) | (0<<ISC10) | (1<<ISC01) | (0<<ISC00);	// The falling edge of INT0 generates an interrupt request
	EICRA	=	(0<<ISC11) | (0<<ISC10) | (1<<ISC01) | (0<<ISC00);	// The rising edge of INT0 generates an interrupt request
 4ca:	89 e6       	ldi	r24, 0x69	; 105
 4cc:	90 e0       	ldi	r25, 0x00	; 0
 4ce:	22 e0       	ldi	r18, 0x02	; 2
 4d0:	fc 01       	movw	r30, r24
 4d2:	20 83       	st	Z, r18
	EIMSK	=	(0<<INT1) | (1<<INT0);								// External Interrupt Request 0 Enable
 4d4:	8d e3       	ldi	r24, 0x3D	; 61
 4d6:	90 e0       	ldi	r25, 0x00	; 0
 4d8:	21 e0       	ldi	r18, 0x01	; 1
 4da:	fc 01       	movw	r30, r24
 4dc:	20 83       	st	Z, r18
	EIFR	=	(1<<INTF1) | (1<<INTF0);							// Clear interrupt flag to avoid false triggers
 4de:	8c e3       	ldi	r24, 0x3C	; 60
 4e0:	90 e0       	ldi	r25, 0x00	; 0
 4e2:	23 e0       	ldi	r18, 0x03	; 3
 4e4:	fc 01       	movw	r30, r24
 4e6:	20 83       	st	Z, r18
	//sei();															// Set global interrupt enable bit
}
 4e8:	00 00       	nop
 4ea:	df 91       	pop	r29
 4ec:	cf 91       	pop	r28
 4ee:	08 95       	ret

Disassembly of section .text.InitGPIO:

0000040a <InitGPIO>:
	// Use timer2 to generate 50Hz PWM at OC2B (fast PWm, 8-bit, TOP = 0xFF (+/-61Hz))
	TCCR2A	=	(1<<WGM20) | (1<<WGM21) | (1<<COM2B1);	// Configure timer in PWM mode, non inverting
	TCCR2B  =	(1<<CS20) | (1<<CS21) | (1<<CS22);		// Set timer clock source to clock/1024 (15625Khz)
	OCR2B	=	0;										// 0% duty cycle
	DDRD	=	DDRD | (1<<3);						// Make sure PORTD.3 is set as output for the servo
}
 40a:	cf 93       	push	r28
 40c:	df 93       	push	r29
 40e:	cd b7       	in	r28, 0x3d	; 61
 410:	de b7       	in	r29, 0x3e	; 62
 412:	87 e2       	ldi	r24, 0x27	; 39
 414:	90 e0       	ldi	r25, 0x00	; 0
 416:	27 e2       	ldi	r18, 0x27	; 39
 418:	30 e0       	ldi	r19, 0x00	; 0
 41a:	f9 01       	movw	r30, r18
 41c:	20 81       	ld	r18, Z
 41e:	27 63       	ori	r18, 0x37	; 55
 420:	fc 01       	movw	r30, r24
 422:	20 83       	st	Z, r18
 424:	8a e2       	ldi	r24, 0x2A	; 42
 426:	90 e0       	ldi	r25, 0x00	; 0
 428:	2a e2       	ldi	r18, 0x2A	; 42
 42a:	30 e0       	ldi	r19, 0x00	; 0
 42c:	f9 01       	movw	r30, r18
 42e:	20 81       	ld	r18, Z
 430:	2f 7e       	andi	r18, 0xEF	; 239
 432:	fc 01       	movw	r30, r24
 434:	20 83       	st	Z, r18
 436:	84 e2       	ldi	r24, 0x24	; 36
 438:	90 e0       	ldi	r25, 0x00	; 0
 43a:	24 e2       	ldi	r18, 0x24	; 36
 43c:	30 e0       	ldi	r19, 0x00	; 0
 43e:	f9 01       	movw	r30, r18
 440:	20 81       	ld	r18, Z
 442:	23 60       	ori	r18, 0x03	; 3
 444:	fc 01       	movw	r30, r24
 446:	20 83       	st	Z, r18
 448:	00 00       	nop
 44a:	df 91       	pop	r29
 44c:	cf 91       	pop	r28
 44e:	08 95       	ret

Disassembly of section .text.__vector_14:

000000c8 <__vector_14>:
volatile unsigned int MotorTimer = 0;

// Interrupt triggers every 1mS
// ----------------------------
ISR (TIMER0_COMPA_vect)
{
  c8:	1f 92       	push	r1
  ca:	0f 92       	push	r0
  cc:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7f805f>
  d0:	0f 92       	push	r0
  d2:	11 24       	eor	r1, r1
  d4:	2f 93       	push	r18
  d6:	3f 93       	push	r19
  d8:	8f 93       	push	r24
  da:	9f 93       	push	r25
  dc:	ef 93       	push	r30
  de:	ff 93       	push	r31
  e0:	cf 93       	push	r28
  e2:	df 93       	push	r29
  e4:	cd b7       	in	r28, 0x3d	; 61
  e6:	de b7       	in	r29, 0x3e	; 62
	// Delay used for debouce of switch on INT0
	// ----------------------------------------
	if (g_INT0)
  e8:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <g_INT0>
  ec:	88 23       	and	r24, r24
  ee:	31 f1       	breq	.+76     	; 0x13c <__vector_14+0x74>
	{
		// Check if the delay has passed AND button is actually pressed down
		if ( (++g_Delay > DELAY) & ((PIND & (1<<2)) == 0))
  f0:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <g_Delay>
  f4:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <g_Delay+0x1>
  f8:	01 96       	adiw	r24, 0x01	; 1
  fa:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <g_Delay+0x1>
  fe:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_Delay>
 102:	31 e0       	ldi	r19, 0x01	; 1
 104:	0b 97       	sbiw	r24, 0x0b	; 11
 106:	08 f4       	brcc	.+2      	; 0x10a <__vector_14+0x42>
 108:	30 e0       	ldi	r19, 0x00	; 0
 10a:	89 e2       	ldi	r24, 0x29	; 41
 10c:	90 e0       	ldi	r25, 0x00	; 0
 10e:	fc 01       	movw	r30, r24
 110:	80 81       	ld	r24, Z
 112:	88 2f       	mov	r24, r24
 114:	90 e0       	ldi	r25, 0x00	; 0
 116:	84 70       	andi	r24, 0x04	; 4
 118:	99 27       	eor	r25, r25
 11a:	21 e0       	ldi	r18, 0x01	; 1
 11c:	89 2b       	or	r24, r25
 11e:	09 f0       	breq	.+2      	; 0x122 <__vector_14+0x5a>
 120:	20 e0       	ldi	r18, 0x00	; 0
 122:	83 2f       	mov	r24, r19
 124:	82 23       	and	r24, r18
 126:	88 23       	and	r24, r24
 128:	49 f0       	breq	.+18     	; 0x13c <__vector_14+0x74>
		{
			g_ButtonPressed = 1;
 12a:	81 e0       	ldi	r24, 0x01	; 1
 12c:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <g_ButtonPressed>
			g_Delay = 0;
 130:	10 92 10 01 	sts	0x0110, r1	; 0x800110 <g_Delay+0x1>
 134:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <g_Delay>
			g_INT0 = 0;
 138:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <g_INT0>
		}
	}
	
	// General purpose timer value
	// ---------------------------
	g_Timer0++;
 13c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <g_Timer0>
 140:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <g_Timer0+0x1>
 144:	01 96       	adiw	r24, 0x01	; 1
 146:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <g_Timer0+0x1>
 14a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <g_Timer0>
	
	g_MotorPulseTimer++;
 14e:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <g_MotorPulseTimer>
 152:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <g_MotorPulseTimer+0x1>
 156:	01 96       	adiw	r24, 0x01	; 1
 158:	90 93 08 01 	sts	0x0108, r25	; 0x800108 <g_MotorPulseTimer+0x1>
 15c:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <g_MotorPulseTimer>
	g_MotorTimer++;
 160:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_MotorTimer>
 164:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_MotorTimer+0x1>
 168:	01 96       	adiw	r24, 0x01	; 1
 16a:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <g_MotorTimer+0x1>
 16e:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <g_MotorTimer>
	
	
	//Timer for blinking LED's
	//------------------------
	g_BlinkTimer++;
 172:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <g_BlinkTimer>
 176:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <g_BlinkTimer+0x1>
 17a:	01 96       	adiw	r24, 0x01	; 1
 17c:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <g_BlinkTimer+0x1>
 180:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <g_BlinkTimer>
	
	// ADC timer
	// ---------
	MotorTimer++;	
 184:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <MotorTimer>
 188:	90 91 16 01 	lds	r25, 0x0116	; 0x800116 <MotorTimer+0x1>
 18c:	01 96       	adiw	r24, 0x01	; 1
 18e:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <MotorTimer+0x1>
 192:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <MotorTimer>
	
	// Time counter (HH:MM:SS)
	// -----------------------
	if (++g_OnTimems == 1000)
 196:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <_end>
 19a:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <_end+0x1>
 19e:	01 96       	adiw	r24, 0x01	; 1
 1a0:	90 93 14 01 	sts	0x0114, r25	; 0x800114 <_end+0x1>
 1a4:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <_end>
 1a8:	88 3e       	cpi	r24, 0xE8	; 232
 1aa:	93 40       	sbci	r25, 0x03	; 3
 1ac:	f9 f4       	brne	.+62     	; 0x1ec <__vector_14+0x124>
	{
		g_OnTimems = 0;
 1ae:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <_end+0x1>
 1b2:	10 92 13 01 	sts	0x0113, r1	; 0x800113 <_end>
		//g_DisplayDirty = 1;
		if (++g_OnTimeSec == 60)
 1b6:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <g_OnTimeSec>
 1ba:	8f 5f       	subi	r24, 0xFF	; 255
 1bc:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <g_OnTimeSec>
 1c0:	8c 33       	cpi	r24, 0x3C	; 60
 1c2:	a1 f4       	brne	.+40     	; 0x1ec <__vector_14+0x124>
		{		
			g_OnTimeSec = 0;
 1c4:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <g_OnTimeSec>
			if (++g_OnTimeMin == 60)
 1c8:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <g_OnTimeMin>
 1cc:	8f 5f       	subi	r24, 0xFF	; 255
 1ce:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <g_OnTimeMin>
 1d2:	8c 33       	cpi	r24, 0x3C	; 60
 1d4:	59 f4       	brne	.+22     	; 0x1ec <__vector_14+0x124>
			{
				g_OnTimeMin = 0;
 1d6:	10 92 18 01 	sts	0x0118, r1	; 0x800118 <g_OnTimeMin>
				if (++g_OnTimeHr == 25)
 1da:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <g_OnTimeHr>
 1de:	8f 5f       	subi	r24, 0xFF	; 255
 1e0:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <g_OnTimeHr>
 1e4:	89 31       	cpi	r24, 0x19	; 25
 1e6:	11 f4       	brne	.+4      	; 0x1ec <__vector_14+0x124>
				{
					g_OnTimeHr = 0;
 1e8:	10 92 19 01 	sts	0x0119, r1	; 0x800119 <g_OnTimeHr>
				}
			}
		}
	}
}
 1ec:	00 00       	nop
 1ee:	df 91       	pop	r29
 1f0:	cf 91       	pop	r28
 1f2:	ff 91       	pop	r31
 1f4:	ef 91       	pop	r30
 1f6:	9f 91       	pop	r25
 1f8:	8f 91       	pop	r24
 1fa:	3f 91       	pop	r19
 1fc:	2f 91       	pop	r18
 1fe:	0f 90       	pop	r0
 200:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7f805f>
 204:	0f 90       	pop	r0
 206:	1f 90       	pop	r1
 208:	18 95       	reti

Disassembly of section .text.__vector_1:

0000048a <__vector_1>:

// Interrupt triggers on button pressed (PORTD.2, Arduino port 2)
// --------------------------------------------------------------
ISR (INT0_vect)
{
 48a:	1f 92       	push	r1
 48c:	0f 92       	push	r0
 48e:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7f805f>
 492:	0f 92       	push	r0
 494:	11 24       	eor	r1, r1
 496:	8f 93       	push	r24
 498:	cf 93       	push	r28
 49a:	df 93       	push	r29
 49c:	cd b7       	in	r28, 0x3d	; 61
 49e:	de b7       	in	r29, 0x3e	; 62
	g_INT0 = 1;
 4a0:	81 e0       	ldi	r24, 0x01	; 1
 4a2:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <g_INT0>
	g_Delay = 0;
 4a6:	10 92 10 01 	sts	0x0110, r1	; 0x800110 <g_Delay+0x1>
 4aa:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <g_Delay>
}
 4ae:	00 00       	nop
 4b0:	df 91       	pop	r29
 4b2:	cf 91       	pop	r28
 4b4:	8f 91       	pop	r24
 4b6:	0f 90       	pop	r0
 4b8:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7f805f>
 4bc:	0f 90       	pop	r0
 4be:	1f 90       	pop	r1
 4c0:	18 95       	reti

Disassembly of section .text.main:

0000020a <main>:
unsigned char g_PowerLEDState;
unsigned char g_AmbientLEDState;
volatile unsigned char g_RFState;

int main(void)
{
 20a:	cf 93       	push	r28
 20c:	df 93       	push	r29
 20e:	cd b7       	in	r28, 0x3d	; 61
 210:	de b7       	in	r29, 0x3e	; 62
	g_ButtonPressed = 0;
 212:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <g_ButtonPressed>
	g_Timer0 = 0;
 216:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <g_Timer0+0x1>
 21a:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <g_Timer0>
	g_LedState = 0;
 21e:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <g_LedState>
	
	gStateMachine = STATE_IDLE;
 222:	82 e0       	ldi	r24, 0x02	; 2
 224:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <gStateMachine>
	
	setup();
 228:	0e 94 93 01 	call	0x326	; 0x326 <setup>
		
    while(1)
    {
        switch (gStateMachine)
 22c:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <gStateMachine>
 230:	88 2f       	mov	r24, r24
 232:	90 e0       	ldi	r25, 0x00	; 0
 234:	83 30       	cpi	r24, 0x03	; 3
 236:	91 05       	cpc	r25, r1
 238:	81 f1       	breq	.+96     	; 0x29a <main+0x90>
 23a:	84 30       	cpi	r24, 0x04	; 4
 23c:	91 05       	cpc	r25, r1
 23e:	34 f4       	brge	.+12     	; 0x24c <main+0x42>
 240:	81 30       	cpi	r24, 0x01	; 1
 242:	91 05       	cpc	r25, r1
 244:	59 f0       	breq	.+22     	; 0x25c <main+0x52>
 246:	02 97       	sbiw	r24, 0x02	; 2
 248:	99 f0       	breq	.+38     	; 0x270 <main+0x66>
			break;
			
			default:
			/*Should never enter this state*/
			/*Add fault handling*/
			break;			
 24a:	50 c0       	rjmp	.+160    	; 0x2ec <main+0xe2>
	
	setup();
		
    while(1)
    {
        switch (gStateMachine)
 24c:	84 30       	cpi	r24, 0x04	; 4
 24e:	91 05       	cpc	r25, r1
 250:	09 f4       	brne	.+2      	; 0x254 <main+0x4a>
 252:	47 c0       	rjmp	.+142    	; 0x2e2 <main+0xd8>
 254:	05 97       	sbiw	r24, 0x05	; 5
 256:	09 f4       	brne	.+2      	; 0x25a <main+0x50>
 258:	46 c0       	rjmp	.+140    	; 0x2e6 <main+0xdc>
			break;
			
			default:
			/*Should never enter this state*/
			/*Add fault handling*/
			break;			
 25a:	48 c0       	rjmp	.+144    	; 0x2ec <main+0xe2>
    while(1)
    {
        switch (gStateMachine)
		{
			case STATE_BOOT:
				g_Delay++;				
 25c:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <g_Delay>
 260:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <g_Delay+0x1>
 264:	01 96       	adiw	r24, 0x01	; 1
 266:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <g_Delay+0x1>
 26a:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_Delay>
			break;
 26e:	3e c0       	rjmp	.+124    	; 0x2ec <main+0xe2>
			
			case STATE_IDLE:
				ControlPowerLED(OFF);
 270:	80 e0       	ldi	r24, 0x00	; 0
 272:	0e 94 bc 01 	call	0x378	; 0x378 <ControlPowerLED>
				ControlMotorEnable(ON);
 276:	81 e0       	ldi	r24, 0x01	; 1
 278:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ControlMotorEnable>
				g_Delay++;
 27c:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <g_Delay>
 280:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <g_Delay+0x1>
 284:	01 96       	adiw	r24, 0x01	; 1
 286:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <g_Delay+0x1>
 28a:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_Delay>
				gStateMachine++;
 28e:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <gStateMachine>
 292:	8f 5f       	subi	r24, 0xFF	; 255
 294:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <gStateMachine>
			break;
 298:	29 c0       	rjmp	.+82     	; 0x2ec <main+0xe2>
			
			case STATE_ROTATE:
				g_Delay++;
 29a:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <g_Delay>
 29e:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <g_Delay+0x1>
 2a2:	01 96       	adiw	r24, 0x01	; 1
 2a4:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <g_Delay+0x1>
 2a8:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <g_Delay>
				/*Increment motor pulses*/
				
				if (g_MotorTimer == 2)
 2ac:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_MotorTimer>
 2b0:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_MotorTimer+0x1>
 2b4:	02 97       	sbiw	r24, 0x02	; 2
 2b6:	29 f4       	brne	.+10     	; 0x2c2 <main+0xb8>
				{
					PINC = (1<< MotorStep);
 2b8:	86 e2       	ldi	r24, 0x26	; 38
 2ba:	90 e0       	ldi	r25, 0x00	; 0
 2bc:	24 e0       	ldi	r18, 0x04	; 4
 2be:	fc 01       	movw	r30, r24
 2c0:	20 83       	st	Z, r18
				}
				
				if (g_MotorTimer > 2)
 2c2:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_MotorTimer>
 2c6:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_MotorTimer+0x1>
 2ca:	03 97       	sbiw	r24, 0x03	; 3
 2cc:	70 f0       	brcs	.+28     	; 0x2ea <main+0xe0>
				{
					PINC = (1<< MotorStep);
 2ce:	86 e2       	ldi	r24, 0x26	; 38
 2d0:	90 e0       	ldi	r25, 0x00	; 0
 2d2:	24 e0       	ldi	r18, 0x04	; 4
 2d4:	fc 01       	movw	r30, r24
 2d6:	20 83       	st	Z, r18
					g_MotorTimer = 0;
 2d8:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <g_MotorTimer+0x1>
 2dc:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <g_MotorTimer>
				}
			break;
 2e0:	04 c0       	rjmp	.+8      	; 0x2ea <main+0xe0>
			
			case STATE_DIMMING:
			
			break;
 2e2:	00 00       	nop
 2e4:	03 c0       	rjmp	.+6      	; 0x2ec <main+0xe2>

			case STATE_SPEEDADJUST:
			
			break;
 2e6:	00 00       	nop
 2e8:	01 c0       	rjmp	.+2      	; 0x2ec <main+0xe2>
				if (g_MotorTimer > 2)
				{
					PINC = (1<< MotorStep);
					g_MotorTimer = 0;
				}
			break;
 2ea:	00 00       	nop
			/*Should never enter this state*/
			/*Add fault handling*/
			break;			
		}
		
		if (g_Timer0 == 100)
 2ec:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <g_Timer0>
 2f0:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <g_Timer0+0x1>
 2f4:	84 36       	cpi	r24, 0x64	; 100
 2f6:	91 05       	cpc	r25, r1
 2f8:	31 f4       	brne	.+12     	; 0x306 <main+0xfc>
		{
			//ControlPowerLED(ON);
			TogglePowerLED();
 2fa:	0e 94 78 02 	call	0x4f0	; 0x4f0 <TogglePowerLED>
			g_Timer0 = 0;
 2fe:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <g_Timer0+0x1>
 302:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <g_Timer0>
		}
		
		if (g_Timer0 > 200)
 306:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <g_Timer0>
 30a:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <g_Timer0+0x1>
 30e:	89 3c       	cpi	r24, 0xC9	; 201
 310:	91 05       	cpc	r25, r1
 312:	08 f4       	brcc	.+2      	; 0x316 <main+0x10c>
 314:	8b cf       	rjmp	.-234    	; 0x22c <main+0x22>
		{
			ControlPowerLED(OFF);
 316:	80 e0       	ldi	r24, 0x00	; 0
 318:	0e 94 bc 01 	call	0x378	; 0x378 <ControlPowerLED>
			g_Timer0 = 0;
 31c:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <g_Timer0+0x1>
 320:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <g_Timer0>
		}
	}
 324:	83 cf       	rjmp	.-250    	; 0x22c <main+0x22>
